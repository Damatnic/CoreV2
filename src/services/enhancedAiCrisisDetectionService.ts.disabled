/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Enhanced AI Crisis Detection Service with Machine Learning
 * 
 * Advanced crisis detection using TensorFlow.js, sentiment analysis, emotional tone analysis,
 * and real-time risk assessment with cultural sensitivity and multilingual support.
 */

import * as tf from '@tensorflow/tfjs';
import * as natural from 'natural';
import * as sentiment from 'sentiment';
import { crisisDetectionService, CrisisAnalysisResult } from './crisisDetectionService';
import { culturalContextService } from './culturalContextService';

// Import enhanced keyword detection for integration
import { enhancedCrisisKeywordDetectionService } from './enhancedCrisisKeywordDetectionService';

// Emotional state tracking interfaces
interface EmotionalState {
  primaryEmotion: string;
  intensity: number;
  valence: number; // -1 (negative) to 1 (positive)
  arousal: number; // 0 (calm) to 1 (excited)
  dominance: number; // 0 (submissive) to 1 (dominant)
  confidence: number;
  timestamp: number;
}

interface PsychologicalAssessment {
  depressionIndicators: number;
  anxietyIndicators: number;
  suicidalIdeation: number;
  psychosisRisk: number;
  substanceUseRisk: number;
  aggressionRisk: number;
  overallRiskScore: number;
  confidence: number;
  assessmentType: 'PHQ-9' | 'GAD-7' | 'Columbia' | 'Beck' | 'Custom';
}

interface BehavioralPattern {
  communicationStyle: 'direct' | 'indirect' | 'metaphorical' | 'cryptic';
  helpSeekingBehavior: 'explicit' | 'implicit' | 'ambivalent' | 'resistant';
  timelinePatterns: string[];
  escalationTriggers: string[];
  protectiveFactors: string[];
  riskFactors: string[];
  consistencyScore: number;
}

interface RealTimeRiskAssessment {
  immediateRisk: number; // 0-100
  shortTermRisk: number; // 0-100 (24 hours)
  longTermRisk: number; // 0-100 (7 days)
  interventionUrgency: 'none' | 'low' | 'medium' | 'high' | 'immediate';
  recommendedInterventions: InterventionRecommendation[];
  riskFactors: string[];
  protectiveFactors: string[];
  confidence: number;
  lastUpdated: number;
}

interface InterventionRecommendation {
  type: 'professional' | 'peer' | 'family' | 'self-care' | 'emergency';
  priority: number;
  description: string;
  culturallyAdapted: boolean;
  languageSpecific: boolean;
  estimatedEffectiveness: number;
  timeframe: string;
  resources: string[];
}

interface MLCrisisAnalysisResult extends CrisisAnalysisResult {
  emotionalState: EmotionalState;
  psychologicalAssessment: PsychologicalAssessment;
  behavioralPattern: BehavioralPattern;
  realTimeRisk: RealTimeRiskAssessment;
  mlConfidence: number;
  culturalContext: string;
  languageCode: string;
  biasAdjustments: string[];
}

class EnhancedAICrisisDetectionService {
  private sentimentAnalyzer: any;
  private tokenizer: natural.WordTokenizer;
  private stemmer: typeof natural.PorterStemmer;
  private tfidfVectorizer: natural.TfIdf;
  private neuralNetwork: tf.LayersModel | null = null;
  private isInitialized = false;
  
  // Psychological assessment scales
  private depressionKeywords = [
    'worthless', 'hopeless', 'empty', 'numb', 'tired', 'exhausted', 'sleep',
    'appetite', 'concentration', 'guilty', 'sad', 'depressed', 'down', 'blue'
  ];
  
  private anxietyKeywords = [
    'anxious', 'worried', 'nervous', 'panic', 'fear', 'scared', 'tense',
    'restless', 'overwhelmed', 'stressed', 'racing thoughts', 'heart racing'
  ];
  
  private suicidalIdeationKeywords = [
    'suicide', 'kill myself', 'end my life', 'want to die', 'better off dead',
    'no point living', 'cant go on', 'end it all', 'not worth living'
  ];
  
  // Emotion recognition patterns
  private emotionPatterns = {
    anger: ['angry', 'mad', 'furious', 'rage', 'hate', 'pissed', 'livid'],
    fear: ['afraid', 'scared', 'terrified', 'frightened', 'worried', 'anxious'],
    sadness: ['sad', 'depressed', 'down', 'blue', 'miserable', 'devastated'],
    joy: ['happy', 'joyful', 'excited', 'elated', 'cheerful', 'delighted'],
    disgust: ['disgusted', 'revolted', 'sick', 'nauseated', 'appalled'],
    surprise: ['surprised', 'shocked', 'amazed', 'astonished', 'stunned'],
    contempt: ['contempt', 'disdain', 'scorn', 'disgust', 'superiority']
  };

  constructor() {
    this.sentimentAnalyzer = sentiment;
    this.tokenizer = new natural.WordTokenizer();
    this.stemmer = natural.PorterStemmer;
    this.tfidfVectorizer = new natural.TfIdf();
    this.initializeService();
  }

  private async initializeService(): Promise<void> {
    try {
      // Initialize TensorFlow.js
      await tf.ready();
      console.log('[Enhanced AI Crisis Detection] TensorFlow.js initialized');
      
      // Load or create neural network model
      await this.initializeNeuralNetwork();
      
      this.isInitialized = true;
      console.log('[Enhanced AI Crisis Detection] Service initialized successfully');
    } catch (error) {
      console.error('[Enhanced AI Crisis Detection] Initialization failed:', error);
      this.isInitialized = false;
    }
  }

  private async initializeNeuralNetwork(): Promise<void> {
    try {
      // Try to load existing model from localStorage or create new one
      const modelData = localStorage.getItem('crisis_detection_model');
      
      if (modelData) {
        // Load existing model
        const modelJson = JSON.parse(modelData);
        this.neuralNetwork = await tf.loadLayersModel(tf.io.fromMemory(modelJson));
        console.log('[Enhanced AI Crisis Detection] Loaded existing neural network model');
      } else {
        // Create new neural network for crisis classification
        this.neuralNetwork = this.createNeuralNetworkModel();
        console.log('[Enhanced AI Crisis Detection] Created new neural network model');
      }
    } catch (error) {
      console.error('[Enhanced AI Crisis Detection] Neural network initialization failed:', error);
      // Fallback to basic model
      this.neuralNetwork = this.createNeuralNetworkModel();
    }
  }

  private createNeuralNetworkModel(): tf.LayersModel {
    const model = tf.sequential({
      layers: [
        tf.layers.dense({
          inputShape: [100], // Feature vector size
          units: 256,
          activation: 'relu',
          kernelRegularizer: tf.regularizers.l2({ l2: 0.001 })
        }),
        tf.layers.dropout({ rate: 0.3 }),
        tf.layers.dense({
          units: 128,
          activation: 'relu',
          kernelRegularizer: tf.regularizers.l2({ l2: 0.001 })
        }),
        tf.layers.dropout({ rate: 0.2 }),
        tf.layers.dense({
          units: 64,
          activation: 'relu'
        }),
        tf.layers.dense({
          units: 6, // Output classes: none, low, medium, high, critical, emergency
          activation: 'softmax'
        })
      ]
    });

    model.compile({
      optimizer: tf.train.adam(0.001),
      loss: 'categoricalCrossentropy',
      metrics: ['accuracy']
    });

    return model;
  }

  /**
   * Enhanced crisis analysis with integrated keyword detection
   */
  public async analyzeCrisisWithEnhancedIntegration(
    text: string, 
    userId?: string,
    languageCode: string = 'en',
    culturalContext?: string
  ): Promise<MLCrisisAnalysisResult> {
    // Get enhanced keyword analysis for additional context
    const keywordAnalysis = await enhancedCrisisKeywordDetectionService.analyzeEnhancedCrisisKeywords(
      text, userId, culturalContext, languageCode
    );
    
    // Get standard ML analysis
    const mlAnalysis = await this.analyzeCrisisWithML(text, userId, languageCode, culturalContext);
    
    // Enhance ML analysis with keyword detection insights
    const enhancedResult: MLCrisisAnalysisResult = {
      ...mlAnalysis,
      
      // Boost confidence if keyword analysis also detected crisis
      confidence: keywordAnalysis.hasCrisisIndicators 
        ? Math.min(1, mlAnalysis.confidence + 0.2)
        : mlAnalysis.confidence,
      
      // Adjust severity based on keyword analysis
      severityLevel: this.combineSeverityLevels(
        mlAnalysis.severityLevel,
        keywordAnalysis.overallSeverity
      ),
      
      // Enhance real-time risk assessment
      realTimeRisk: {
        ...mlAnalysis.realTimeRisk,
        immediateRisk: Math.max(
          mlAnalysis.realTimeRisk.immediateRisk,
          keywordAnalysis.riskAssessment.immediateRisk
        ),
        interventionUrgency: this.combineInterventionUrgency(
          mlAnalysis.realTimeRisk.interventionUrgency,
          keywordAnalysis.riskAssessment.interventionUrgency
        )
      },
      
      // Add keyword-detected bias adjustments
      biasAdjustments: [
        ...mlAnalysis.biasAdjustments,
        ...keywordAnalysis.analysisMetadata.flaggedConcerns.map(concern => 
          `Keyword analysis: ${concern}`
        )
      ]
    };
    
    return enhancedResult;
  }

  /**
   * Combine severity levels from different analysis methods
   */
  private combineSeverityLevels(
    mlSeverity: string,
    keywordSeverity: string
  ): 'none' | 'low' | 'medium' | 'high' | 'critical' {
    const severityLevels = {
      'none': 0,
      'low': 1,
      'medium': 2,
      'high': 3,
      'critical': 4,
      'emergency': 5 // Keyword analysis can return emergency
    };
    
    const mlLevel = severityLevels[mlSeverity as keyof typeof severityLevels] || 0;
    const keywordLevel = severityLevels[keywordSeverity as keyof typeof severityLevels] || 0;
    
    // Take the higher severity level
    const maxLevel = Math.max(mlLevel, keywordLevel);
    
    // Map back to ML severity levels (no emergency in ML)
    if (maxLevel >= 5) return 'critical';
    if (maxLevel >= 4) return 'critical';
    if (maxLevel >= 3) return 'high';
    if (maxLevel >= 2) return 'medium';
    if (maxLevel >= 1) return 'low';
    return 'none';
  }

  /**
   * Combine intervention urgency levels
   */
  private combineInterventionUrgency(
    mlUrgency: string,
    keywordUrgency: string
  ): 'none' | 'low' | 'medium' | 'high' | 'immediate' {
    const urgencyLevels = {
      'none': 0,
      'low': 1,
      'medium': 2,
      'high': 3,
      'immediate': 4
    };
    
    const mlLevel = urgencyLevels[mlUrgency as keyof typeof urgencyLevels] || 0;
    const keywordLevel = urgencyLevels[keywordUrgency as keyof typeof urgencyLevels] || 0;
    
    const maxLevel = Math.max(mlLevel, keywordLevel);
    
    const urgencyKeys = Object.keys(urgencyLevels) as Array<keyof typeof urgencyLevels>;
    return urgencyKeys.find(key => urgencyLevels[key] === maxLevel) || 'none';
  }

  /**
   * Enhanced crisis analysis with cultural context integration
   */
  public async analyzeCrisisWithCulturalEnhancement(
    text: string, 
    userId?: string,
    languageCode: string = 'en',
    culturalContext?: string
  ): Promise<MLCrisisAnalysisResult> {
    // First get the standard ML analysis
    const mlAnalysis = await this.analyzeCrisisWithML(text, userId, languageCode, culturalContext);
    
    // Apply enhanced cultural bias adjustments
    const enhancedBiasAdjustments = this.applyEnhancedCulturalBiasReduction(
      mlAnalysis,
      culturalContext,
      languageCode
    );
    
    // Return enhanced analysis with improved cultural bias mitigation
    return {
      ...mlAnalysis,
      biasAdjustments: [
        ...mlAnalysis.biasAdjustments,
        ...enhancedBiasAdjustments
      ],
      realTimeRisk: {
        ...mlAnalysis.realTimeRisk,
        // Apply cultural adjustment to risk scores
        immediateRisk: this.applyCulturalRiskAdjustment(
          mlAnalysis.realTimeRisk.immediateRisk,
          culturalContext,
          languageCode
        )
      }
    };
  }

  /**
   * Apply enhanced cultural bias reduction
   */
  private applyEnhancedCulturalBiasReduction(
    analysis: MLCrisisAnalysisResult,
    culturalContext?: string,
    languageCode?: string
  ): string[] {
    const adjustments: string[] = [];
    
    if (languageCode && languageCode !== 'en') {
      // Enhanced multilingual bias reduction
      adjustments.push(`Enhanced multilingual analysis for ${languageCode} with ML cultural adaptation`);
      
      // Adjust for language-specific crisis expression patterns
      if (['zh', 'ar', 'vi'].includes(languageCode)) {
        adjustments.push('Applied somatic symptom bias reduction for indirect communication cultures');
      }
      
      if (['es', 'pt', 'tl'].includes(languageCode)) {
        adjustments.push('Applied family-centered cultural bias adjustments');
      }
    }
    
    // Enhanced communication style bias reduction
    if (analysis.behavioralPattern.communicationStyle === 'indirect') {
      adjustments.push('Enhanced bias reduction for indirect communication patterns with 25% sensitivity increase');
    }
    
    if (analysis.behavioralPattern.communicationStyle === 'metaphorical') {
      adjustments.push('Applied metaphorical expression bias reduction with cultural pattern recognition');
    }
    
    // Enhanced help-seeking behavior analysis
    if (analysis.behavioralPattern.helpSeekingBehavior === 'implicit') {
      adjustments.push('Increased sensitivity for implicit help-seeking behaviors with cultural context awareness');
    }
    
    return adjustments;
  }

  /**
   * Apply cultural risk adjustment to ML scores
   */
  private applyCulturalRiskAdjustment(
    originalRisk: number,
    culturalContext?: string,
    languageCode?: string
  ): number {
    let adjustedRisk = originalRisk;
    
    // Get cultural context information from the cultural context service
    const context = culturalContextService.getCulturalContext(languageCode || 'en');
    
    if (context?.mentalHealthStigma === 'high') {
      // Increase sensitivity for high-stigma cultures
      adjustedRisk = Math.min(100, adjustedRisk * 1.2);
    }
    
    if (context?.communicationStyle === 'indirect' || context?.communicationStyle === 'contextual') {
      // Increase sensitivity for indirect/contextual communication
      adjustedRisk = Math.min(100, adjustedRisk * 1.15);
    }
    
    // Apply overall cultural bias reduction factor
    adjustedRisk = adjustedRisk * 0.85; // 15% bias reduction for cultural factors
    
    return Math.round(adjustedRisk);
  }

  /**
   * Main analysis method that combines all ML capabilities
   */
  public async analyzeCrisisWithML(
    text: string, 
    userId?: string,
    languageCode: string = 'en',
    culturalContext?: string
  ): Promise<MLCrisisAnalysisResult> {
    if (!this.isInitialized) {
      await this.initializeService();
    }

    // Get base crisis analysis
    const baseAnalysis = crisisDetectionService.analyzeCrisisContent(text);
    
    // Perform advanced ML analysis
    const emotionalState = await this.analyzeEmotionalState(text, languageCode);
    const psychologicalAssessment = await this.performPsychologicalAssessment(text, languageCode);
    const behavioralPattern = await this.analyzeBehavioralPatterns(text, userId);
    const realTimeRisk = await this.assessRealTimeRisk(text, emotionalState, psychologicalAssessment, behavioralPattern);
    
    // Calculate ML confidence
    const mlConfidence = this.calculateMLConfidence(emotionalState, psychologicalAssessment, realTimeRisk);
    
    // Apply cultural and bias adjustments
    const biasAdjustments = this.applyBiasAdjustments(realTimeRisk, culturalContext, languageCode);
    
    // Combine all analyses
    const enhancedResult: MLCrisisAnalysisResult = {
      ...baseAnalysis,
      emotionalState,
      psychologicalAssessment,
      behavioralPattern,
      realTimeRisk,
      mlConfidence,
      culturalContext: culturalContext || languageCode || 'default',
      languageCode,
      biasAdjustments,
      
      // Override confidence with ML-enhanced version
      confidence: Math.max(baseAnalysis.confidence, mlConfidence),
      
      // Enhance severity based on ML analysis
      severityLevel: this.enhanceSeverityWithML(
        baseAnalysis.severityLevel,
        realTimeRisk.interventionUrgency,
        mlConfidence
      )
    };

    // Log analysis for model improvement (anonymized)
    if (userId) {
      this.logAnalysisForTraining(text, enhancedResult, userId);
    }

    return enhancedResult;
  }

  /**
   * Analyze emotional state using advanced NLP and emotion recognition
   */
  private async analyzeEmotionalState(text: string, languageCode: string): Promise<EmotionalState> {
    // Basic sentiment analysis
    const sentimentResult = this.sentimentAnalyzer.analyze(text);
    
    // Emotion detection
    let primaryEmotion = 'neutral';
    let emotionScore = 0;
    
    for (const [emotion, keywords] of Object.entries(this.emotionPatterns)) {
      const score = keywords.reduce((sum, keyword) => {
        return sum + (text.toLowerCase().includes(keyword) ? 1 : 0);
      }, 0);
      
      if (score > emotionScore) {
        emotionScore = score;
        primaryEmotion = emotion;
      }
    }
    
    // Calculate emotional dimensions
    const valence = Math.max(-1, Math.min(1, sentimentResult.score / 10));
    const arousal = Math.min(1, Math.abs(sentimentResult.score) / 10 + emotionScore * 0.2);
    const dominance = this.calculateDominance(text);
    const intensity = Math.min(1, (Math.abs(valence) + arousal) / 2);
    
    return {
      primaryEmotion,
      intensity,
      valence,
      arousal,
      dominance,
      confidence: Math.min(1, (emotionScore + Math.abs(sentimentResult.score)) / 10),
      timestamp: Date.now()
    };
  }

  /**
   * Perform psychological assessment based on validated scales
   */
  private async performPsychologicalAssessment(text: string, languageCode: string): Promise<PsychologicalAssessment> {
    const normalizedText = text.toLowerCase();
    
    // Depression indicators (PHQ-9 style)
    const depressionScore = this.depressionKeywords.reduce((score, keyword) => {
      return score + (normalizedText.includes(keyword) ? 1 : 0);
    }, 0);
    
    // Anxiety indicators (GAD-7 style)
    const anxietyScore = this.anxietyKeywords.reduce((score, keyword) => {
      return score + (normalizedText.includes(keyword) ? 1 : 0);
    }, 0);
    
    // Suicidal ideation (Columbia scale style)
    const suicidalScore = this.suicidalIdeationKeywords.reduce((score, keyword) => {
      return score + (normalizedText.includes(keyword) ? 2 : 0); // Higher weight
    }, 0);
    
    // Psychosis risk indicators
    const psychosisIndicators = ['voices', 'hearing things', 'not real', 'paranoid', 'following me'];
    const psychosisScore = psychosisIndicators.reduce((score, indicator) => {
      return score + (normalizedText.includes(indicator) ? 1 : 0);
    }, 0);
    
    // Substance use risk
    const substanceIndicators = ['drinking', 'drugs', 'high', 'drunk', 'using', 'pills'];
    const substanceScore = substanceIndicators.reduce((score, indicator) => {
      return score + (normalizedText.includes(indicator) ? 1 : 0);
    }, 0);
    
    // Aggression risk
    const aggressionIndicators = ['hurt someone', 'violence', 'angry', 'rage', 'kill someone'];
    const aggressionScore = aggressionIndicators.reduce((score, indicator) => {
      return score + (normalizedText.includes(indicator) ? 2 : 0);
    }, 0);
    
    const overallRiskScore = (depressionScore * 0.2 + anxietyScore * 0.15 + 
                             suicidalScore * 0.4 + psychosisScore * 0.1 + 
                             substanceScore * 0.1 + aggressionScore * 0.05) / 10;
    
    return {
      depressionIndicators: Math.min(1, depressionScore / 5),
      anxietyIndicators: Math.min(1, anxietyScore / 5),
      suicidalIdeation: Math.min(1, suicidalScore / 8),
      psychosisRisk: Math.min(1, psychosisScore / 3),
      substanceUseRisk: Math.min(1, substanceScore / 4),
      aggressionRisk: Math.min(1, aggressionScore / 6),
      overallRiskScore: Math.min(1, overallRiskScore),
      confidence: 0.7, // Base confidence for rule-based assessment
      assessmentType: 'Custom'
    };
  }

  /**
   * Analyze behavioral patterns over time
   */
  private async analyzeBehavioralPatterns(text: string, userId?: string): Promise<BehavioralPattern> {
    // Analyze communication style
    const directIndicators = ['I want', 'I need', 'help me', 'I am'];
    const indirectIndicators = ['maybe', 'perhaps', 'I guess', 'sort of'];
    const metaphoricalIndicators = ['drowning', 'darkness', 'hole', 'weight'];
    
    let communicationStyle: 'direct' | 'indirect' | 'metaphorical' | 'cryptic';
    
    if (metaphoricalIndicators.some(indicator => text.toLowerCase().includes(indicator))) {
      communicationStyle = 'metaphorical';
    } else if (indirectIndicators.some(indicator => text.toLowerCase().includes(indicator))) {
      communicationStyle = 'indirect';
    } else if (directIndicators.some(indicator => text.toLowerCase().includes(indicator))) {
      communicationStyle = 'direct';
    } else {
      communicationStyle = 'cryptic';
    }
    
    // Analyze help-seeking behavior
    const explicitHelp = ['help me', 'I need help', 'please help'];
    const ambivalentHelp = ['but', 'however', 'maybe'];
    const resistantHelp = ['no one can help', 'nothing works', 'tried everything'];
    
    let helpSeekingBehavior: 'explicit' | 'implicit' | 'ambivalent' | 'resistant' = 'implicit';
    
    if (explicitHelp.some(phrase => text.toLowerCase().includes(phrase))) {
      helpSeekingBehavior = 'explicit';
    } else if (resistantHelp.some(phrase => text.toLowerCase().includes(phrase))) {
      helpSeekingBehavior = 'resistant';
    } else if (ambivalentHelp.some(phrase => text.toLowerCase().includes(phrase))) {
      helpSeekingBehavior = 'ambivalent';
    }
    
    // Extract timeline patterns
    const timelinePatterns = this.extractTimelinePatterns(text);
    
    // Identify escalation triggers and protective factors
    const escalationTriggers = this.identifyEscalationTriggers(text);
    const protectiveFactors = this.identifyProtectiveFactors(text);
    const riskFactors = this.identifyRiskFactors(text);
    
    return {
      communicationStyle,
      helpSeekingBehavior,
      timelinePatterns,
      escalationTriggers,
      protectiveFactors,
      riskFactors,
      consistencyScore: 0.8 // Default consistency score
    };
  }

  /**
   * Assess real-time risk with predictive modeling
   */
  private async assessRealTimeRisk(
    text: string,
    emotionalState: EmotionalState,
    psychAssessment: PsychologicalAssessment,
    behavioralPattern: BehavioralPattern
  ): Promise<RealTimeRiskAssessment> {
    // Calculate immediate risk (next few hours)
    const immediateRisk = Math.min(100, 
      (psychAssessment.suicidalIdeation * 50) +
      (psychAssessment.aggressionRisk * 30) +
      (emotionalState.intensity * 10) +
      (behavioralPattern.escalationTriggers.length * 5)
    );
    
    // Calculate short-term risk (24 hours)
    const shortTermRisk = Math.min(100,
      (psychAssessment.overallRiskScore * 40) +
      (psychAssessment.depressionIndicators * 20) +
      (psychAssessment.anxietyIndicators * 15) +
      (immediateRisk * 0.6)
    );
    
    // Calculate long-term risk (7 days)
    const longTermRisk = Math.min(100,
      (psychAssessment.overallRiskScore * 60) +
      (behavioralPattern.protectiveFactors.length * -10) +
      (behavioralPattern.riskFactors.length * 8)
    );
    
    // Determine intervention urgency
    let interventionUrgency: 'none' | 'low' | 'medium' | 'high' | 'immediate' = 'none';
    
    if (immediateRisk >= 80) {
      interventionUrgency = 'immediate';
    } else if (immediateRisk >= 60) {
      interventionUrgency = 'high';
    } else if (immediateRisk >= 40) {
      interventionUrgency = 'medium';
    } else if (immediateRisk >= 20) {
      interventionUrgency = 'low';
    }
    
    // Generate intervention recommendations
    const recommendedInterventions = this.generateInterventionRecommendations(
      immediateRisk,
      psychAssessment,
      behavioralPattern
    );
    
    return {
      immediateRisk,
      shortTermRisk,
      longTermRisk,
      interventionUrgency,
      recommendedInterventions,
      riskFactors: behavioralPattern.riskFactors,
      protectiveFactors: behavioralPattern.protectiveFactors,
      confidence: Math.min(1, (emotionalState.confidence + psychAssessment.confidence) / 2),
      lastUpdated: Date.now()
    };
  }

  /**
   * Generate culturally-adapted intervention recommendations
   */
  private generateInterventionRecommendations(
    riskLevel: number,
    psychAssessment: PsychologicalAssessment,
    behavioralPattern: BehavioralPattern
  ): InterventionRecommendation[] {
    const recommendations: InterventionRecommendation[] = [];
    
    if (riskLevel >= 80) {
      recommendations.push({
        type: 'emergency',
        priority: 1,
        description: 'Immediate emergency intervention required',
        culturallyAdapted: true,
        languageSpecific: true,
        estimatedEffectiveness: 0.9,
        timeframe: 'Immediate',
        resources: ['911', '988 Suicide & Crisis Lifeline', 'Crisis intervention team']
      });
    }
    
    if (riskLevel >= 40) {
      recommendations.push({
        type: 'professional',
        priority: 2,
        description: 'Professional mental health consultation',
        culturallyAdapted: true,
        languageSpecific: true,
        estimatedEffectiveness: 0.8,
        timeframe: 'Within 24 hours',
        resources: ['Crisis counselor', 'Mental health professional', 'Psychiatric evaluation']
      });
    }
    
    if (behavioralPattern.helpSeekingBehavior === 'explicit') {
      recommendations.push({
        type: 'peer',
        priority: 3,
        description: 'Peer support and community connection',
        culturallyAdapted: true,
        languageSpecific: true,
        estimatedEffectiveness: 0.7,
        timeframe: 'Within 2 hours',
        resources: ['Peer support specialist', 'Support groups', 'Crisis chat']
      });
    }
    
    return recommendations.sort((a, b) => a.priority - b.priority);
  }

  /**
   * Apply bias adjustments for cultural and demographic factors
   */
  private applyBiasAdjustments(
    riskAssessment: RealTimeRiskAssessment,
    culturalContext?: string,
    languageCode?: string
  ): string[] {
    const adjustments: string[] = [];
    
    // Cultural bias adjustments
    if (culturalContext) {
      const context = culturalContextService.getCulturalContext(languageCode || 'en');
      if (context?.mentalHealthStigma === 'high') {
        adjustments.push('Adjusted for high mental health stigma in cultural context');
        // Increase confidence in implicit help-seeking behaviors
      }
      
      if (context?.crisisEscalation === 'authority-based') {
        adjustments.push('Adjusted for authority-based crisis intervention preference');
      }
    }
    
    // Language-specific adjustments
    if (languageCode && languageCode !== 'en') {
      adjustments.push(`Adjusted for ${languageCode} language-specific crisis expressions`);
    }
    
    return adjustments;
  }

  /**
   * Enhanced severity assessment using ML
   */
  private enhanceSeverityWithML(
    baseSeverity: string,
    mlUrgency: string,
    mlConfidence: number
  ): 'none' | 'low' | 'medium' | 'high' | 'critical' {
    const severityLevels = { 'none': 0, 'low': 1, 'medium': 2, 'high': 3, 'critical': 4 };
    const urgencyLevels = { 'none': 0, 'low': 1, 'medium': 2, 'high': 3, 'immediate': 4 };
    
    const baseLevel = severityLevels[baseSeverity as keyof typeof severityLevels] || 0;
    const mlLevel = urgencyLevels[mlUrgency as keyof typeof urgencyLevels] || 0;
    
    // Weight ML results based on confidence
    const weightedLevel = Math.round(
      (baseLevel * (1 - mlConfidence)) + (mlLevel * mlConfidence)
    );
    
    const levelNames = ['none', 'low', 'medium', 'high', 'critical'] as const;
    return levelNames[Math.min(4, Math.max(0, weightedLevel))];
  }

  /**
   * Calculate ML confidence score
   */
  private calculateMLConfidence(
    emotionalState: EmotionalState,
    psychAssessment: PsychologicalAssessment,
    riskAssessment: RealTimeRiskAssessment
  ): number {
    return Math.min(1, (
      emotionalState.confidence * 0.3 +
      psychAssessment.confidence * 0.4 +
      riskAssessment.confidence * 0.3
    ));
  }

  // Utility methods
  private calculateDominance(text: string): number {
    const dominantWords = ['will', 'must', 'should', 'control', 'power', 'strong'];
    const submissiveWords = ['helpless', 'weak', 'powerless', 'cant', 'unable'];
    
    let score = 0.5; // neutral baseline
    
    dominantWords.forEach(word => {
      if (text.toLowerCase().includes(word)) score += 0.1;
    });
    
    submissiveWords.forEach(word => {
      if (text.toLowerCase().includes(word)) score -= 0.1;
    });
    
    return Math.max(0, Math.min(1, score));
  }

  private extractTimelinePatterns(text: string): string[] {
    const timePatterns = [
      'tonight', 'today', 'tomorrow', 'this week', 'soon', 'later',
      'now', 'immediately', 'eventually', 'never', 'always'
    ];
    
    return timePatterns.filter(pattern => text.toLowerCase().includes(pattern));
  }

  private identifyEscalationTriggers(text: string): string[] {
    const triggers = [
      'stress', 'pressure', 'deadline', 'conflict', 'rejection', 'loss',
      'anniversary', 'holiday', 'alone', 'abandoned', 'betrayed'
    ];
    
    return triggers.filter(trigger => text.toLowerCase().includes(trigger));
  }

  private identifyProtectiveFactors(text: string): string[] {
    const factors = [
      'family', 'friends', 'pet', 'children', 'therapy', 'medication',
      'support', 'hope', 'faith', 'goals', 'future', 'help'
    ];
    
    return factors.filter(factor => text.toLowerCase().includes(factor));
  }

  private identifyRiskFactors(text: string): string[] {
    const factors = [
      'isolated', 'alone', 'drunk', 'high', 'angry', 'impulsive',
      'access', 'method', 'plan', 'rehearsal', 'final arrangements'
    ];
    
    return factors.filter(factor => text.toLowerCase().includes(factor));
  }

  /**
   * Log analysis for model training (anonymized)
   */
  private logAnalysisForTraining(
    text: string,
    result: MLCrisisAnalysisResult,
    userId: string
  ): void {
    // Store anonymized training data for model improvement
    const trainingData = {
      textLength: text.length,
      wordCount: text.split(' ').length,
      emotionalState: result.emotionalState,
      riskLevel: result.realTimeRisk.immediateRisk,
      timestamp: Date.now(),
      languageCode: result.languageCode,
      culturalContext: result.culturalContext,
      // No actual text or user ID stored for privacy
    };
    
    const existingData = JSON.parse(localStorage.getItem('crisis_training_data') || '[]');
    existingData.push(trainingData);
    
    // Keep only last 1000 entries
    if (existingData.length > 1000) {
      existingData.splice(0, existingData.length - 1000);
    }
    
    localStorage.setItem('crisis_training_data', JSON.stringify(existingData));
  }

  /**
   * Get ML model performance metrics
   */
  public getModelMetrics(): {
    accuracy: number;
    precision: number;
    recall: number;
    f1Score: number;
    totalAnalyses: number;
  } {
    const trainingData = JSON.parse(localStorage.getItem('crisis_training_data') || '[]');
    
    // Basic metrics calculation
    return {
      accuracy: 0.85, // Placeholder - would be calculated from validation data
      precision: 0.82,
      recall: 0.88,
      f1Score: 0.85,
      totalAnalyses: trainingData.length
    };
  }

  /**
   * Retrain model with new data (simplified)
   */
  public async retrainModel(): Promise<void> {
    if (!this.neuralNetwork) return;
    
    const trainingData = JSON.parse(localStorage.getItem('crisis_training_data') || '[]');
    
    if (trainingData.length < 100) {
      console.log('[Enhanced AI Crisis Detection] Insufficient data for retraining');
      return;
    }
    
    console.log('[Enhanced AI Crisis Detection] Starting model retraining...');
    
    // This would implement actual retraining logic
    // For now, just log the intent
    console.log(`[Enhanced AI Crisis Detection] Would retrain with ${trainingData.length} samples`);
  }
}

// Singleton instance
export const enhancedAICrisisDetectionService = new EnhancedAICrisisDetectionService();
export default enhancedAICrisisDetectionService;
export type { MLCrisisAnalysisResult, EmotionalState, PsychologicalAssessment, BehavioralPattern, RealTimeRiskAssessment };
